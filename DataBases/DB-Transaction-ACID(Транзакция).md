# Transaction — ACID (Транзакция)

***Транзакция*** — это набор операций по работе с [базой данных (БД)](DB-DataBases.md),
объединенных в одну атомарную пачку, которые должны либо выполниться все, либо ни одной. 

**Transaction Lifespan** (жизненные состояния транзакции): <br> 
● Transaction **BEGIN**; <br>
● Transaction **COMMIT**; <br>
● Transaction **ROLLBACK**; <br>
● Transaction unexpected ending = **ROLLBACK** (e.g. crash) (сбой, непредвиденное завершение)

Транзакционные БД (базы, работающие через транзакции) должны выполнять требования 
***ACID***, которые обеспечивают безопасность данных.  

## ACID

### `<A>` Atomicity — Атомарность

> Транзакция должна быть **неделимой** !!!
>
>Не можем проводить транзакцию и остановиться *посредине* !<br>
Мы должны быть уверенны, что код **выполниться до конца (COMMIT)** 
или **произойдет откат (ROLLBACK)**

Все запросы в транзакции должны быть успешными: <br>
● В случае сбоя одного запроса все предыдущие успешные запросы в транзакции
следует откатить. <br>
● Если база данных вышла из строя до фиксации транзакции,
все успешные запросы в транзакциях должны откатиться.

### `<C>` Consistency — Согласованность

> Если где-то убыло, то где-то должно прибыть !
>
>С одного счета сняли деньги - на другой должны прийти ! 

### `<I>` Isolation — Изолированность

> Транзакции должны не мешать друг другу !

Если две транзакции пытаются параллельно обрабатывать один и тот же набор данных, 
то у них должна быть изоляция друг от друга.

Изоляция бывает разного уровня (см. далее)

### `<D>` Durability — Отказоустойчивость 

>Если в сервер летит метеорит и в это время проходит транзакция, мы должны быть 
> уверены, в не зависимости от последствий, транзакция либо выполниться 
> полностью или откатится !

## ODBC — Уровни изоляции транзакций

***Уровни изоляции транзакций*** — это мера степени, в которой выполняется изоляция
транзакции. <br>
В частности, уровни изоляции транзакций определяются присутствием или
отсутствием следующих явлений:

###  Побочные эффекты параллельных транзакций  

#### `Dirty Reads` — Грязные чтения  

**«Грязное» чтение происходит, когда транзакция считывает данные, которые 
еще не были зафиксированы.**<br> 

*Например*: <br>
Транзакция *<1>* обновляет строку. <br>
Транзакция *<2>* считывает обновленную строку до того, 
как транзакция *<1>* зафиксирует обновление. <br>
Если транзакция *<1>* выполняет откат изменений, то транзакция *<2>* будет считать 
данные, которые *никогда не существовали*.

>                             A = 500
>                               |
>      <Кассир 1>      -300 --> |
>                               | ----->       <Кассир 2>
>                               |               A = 200
>                  Откат <----- |
>         A = 500               |     
>                             A = 500
> 
>На счету А лежит 500 $.
>
><Кассир 1> списал 300 $. <br>
>Потом передумал и сделал откат - на выходе остались те же 500 $.
>
><Кассир 2> понадобилась информация по этому счету и он ее считал до того, 
> как <Кассир 1> закрыл свою транзакцию.
>
>Итог — <Кассир 2> считал неверную сумму, построил неверный отчет/отказал в визе
>платежеспособному гражданину и т.д.

#### `Non-Repeatable Reads` — Неповторяемые чтения 

**Неповторяемое чтение происходит, когда транзакция дважды считывает 
одну и ту же строку, но каждый раз получает разные данные.** <br>

*Например*: <br>
Транзакция *<1>* считывает строку. <br>
Транзакция *<2>* обновляет или удаляет эту строку и фиксирует обновление 
или удаление. <br>
Если транзакция *<1>* пересчитывает строку, она получает *различные значения строки* 
или обнаруживает, что строка была удалена.

>                        Таблица данных
>                               |
>      <Кассир 1>    Min <----- |
>                               | ----->       <Кассир 2>
>                               | <-----        Поменял данные
>                    Max <----- |
>                               |     
>
>Есть некие данные.
>
><Кассир 1> строит отчет. <br>
>Операции идут последовательно для каждой колонки. <br>
>Система считала данные, записала в первую колонку (например, взяв минимум от них).
>
><Кассир 2> влез в эту таблицу данных и изменил некоторые счета в ней.
>
><Кассир 1> продолжает построение отчета. <br>
>И во вторую колонку система считывает уже новые данные.
>
>Итог - отчет построен на основании разных данных.


#### `Phantom Reads` — Фантомное чтение 
**Фантом — это строка, которая соответствует условиям поиска, но изначально не 
отображается.**

*Например*: <br>
Транзакция *<1>* считывает набор строк, удовлетворяющих некоторым условиям поиска. <br>
Транзакция *<2>* создает новую строку (посредством обновления или вставки), которая 
соответствует условиям поиска для транзакции *<1>*. <br>
Если транзакция *<1>* выполняет инструкцию, которая считывает строки, она получает 
другой набор строк.

>                        Таблица данных
>                               |
>      <Кассир 1>    Min <----- |
>                               | ----->       <Кассир 2>
>                               | <-----        Поменял данные
>                    Max <----- |
>                               |     
>
>Есть некие данные.
> 
><Кассир 1> строит отчет. <br>
>Операции идут последовательно для каждой колонки. <br>
>Система считала данные, записала в первую колонку (например, взяв минимум от них).
>
><Кассир 2> влез в эту таблицу данных и добавил новые счета/удалил некоторые старые.
>
><Кассир 1> продолжает построение отчета. <br>
>И во вторую колонку система считывает уже новые данные.
>
>Итог — отчет построен на основании разных данных.
>
>Разница между предыдущим эффектом в том, что в одном случае данные изменяются, 
> а во втором — добавляются/удаляются. То есть меняется ещё и их количество.

#### `Lost Updates` — Потерянные обновления

>                             A = 500
>                               |
>      <Кассир 1>      -300 --> |
>                               | <-- +300      <Кассир 2>
>         A = 200               |                     
>                               |                A = 800
>                             A = 800
> 
>На счету А лежит 500 $.
>
><Кассир 1> списал с него 300 $ <br>
>на выходе получает: 500 - 300 = 200 $.
>
><Кассир 2> тоже решил обратиться к этому же счету и записал туда 300 $, <br>
>пока <Кассир 1> еще не успел закрыть свою транзакцию, <br> 
>так как первая транзакция не закрыта, сумма на счете до сих пор 500 $, <br>
>получаем: 500 + 300 = 800 $.
>
>Итог — мы "потеряли запись" первого кассира, ведь на выходе у нас А = 800, 
> хотя должно быть 500. <br> 
>"Кто последний вписал результат - того и тапки". Получается так.


## Уровни изоляции транзакций
***Четыре уровня изоляции транзакций*** (как определено SQL-92) определяются с 
точки зрения этих явлений. В следующей таблице «X» отмечает каждое обнаруженное 
явление.

**Read uncommitted** — нет изоляции, любые внешние изменения видны для 
транзакции (вне зависимости, зафиксирована она или нет). 

**Read committed** — каждый запрос в транзакции видит только зафиксированные 
изменения других транзакций. 

**Repeatable read** — транзакция гарантирует, что когда запрос читает строку,
эта строка останется неизменной во время ее выполнения.

**Snapshot** — каждый запрос в транзакции видит только те изменения, которые были
совершено до начала транзакции. Это как снимок версии база данных на тот момент.

**Serializable** — транзакции запускаются так, как если бы они следовали одна 
за другой. 

| Уровень изоляции транзакции | Dirty Reads | Lost Updates | Non-Repeatable Reads | Phantom Reads |
|:----------------------------|:-----------:|:------------:|:--------------------:|:-------------:|
| **Read uncommitted**        |    может    |    может     |        может         |     может     |
| **Read committed**          |     --      |    может     |        может         |     может     |
| **Repeatable read**         |     --      |      --      |          --          |     может     |
| **Serializable**            |     --      |      --      |          --          |      --       |


### Реализация уровней изоляции

● Каждая [СУБД](DB-DataBases.md) реализует уровень изоляции по-разному. <br>
● **Пессимистичный** — блокировки на уровне строк, таблиц и страниц во избежание 
потери обновлений. <br>
● **Оптимистичный** — никаких блокировок, просто отслеживается, что 
изменилось, и в этом случае отменяется транзакция. <br>
● Повторяющееся чтение «блокирует» читаемые строки, но это может быть дорого, 
если читать много строк, *Postgres* реализует RR как снимок. Вот почему мы 
не получайте фантомные чтения с Postgres в повторяемом чтении.
● Сериализуемые объекты обычно реализуются с оптимистичным контролем 
параллелизма. Может пессимистично реализовать это с помощью `SELECT FOR UPDATE`.


В следующей таблице описаны простые способы, с помощью которых СУБД может реализовать уровни изоляции транзакций.

| Уровень изоляции транзакций	 | Возможная реализация                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Read committed**           | — Транзакция ожидает, пока разблокируются строки, заблокированные другими транзакциями. Это предотвращает считывание **"грязных" данных**. <br> Транзакция содержит блокировку чтения (если она считывает только строку) или блокировку записи (если она обновляет или удаляет строку) в текущей строке, чтобы предотвратить ее обновление или удаление другими транзакциями. Транзакция освобождает блокировки чтения при перемещении из текущей строки. Он хранит блокировки записи, пока не зафиксируется или не вернется.                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
| **Repeatable read**          | — Транзакция ожидает, пока разблокируются строки, заблокированные другими транзакциями. Это предотвращает считывание **"грязных" данных**. <br> — Транзакция содержит блокировки чтения для всех строк, которые она возвращает в приложение, и блокировки записи для всех строк, которые она вставляет, обновляет или удаляет. <br>Поскольку другие транзакции не могут обновлять или удалять эти строки, текущая транзакция позволяет избежать **неповторяемых операций чтения**. Транзакция освобождает свои блокировки при фиксации или откате.                                                                                                                                                            |
| **Serializable**             | — Транзакция ожидает, пока разблокируются строки, заблокированные другими транзакциями. Это предотвращает считывание **"грязных" данных**. <br>— Транзакция удерживает блокировку чтения (если она считывает только строки) или блокировку записи (если она может обновлять или удалять строки) в диапазоне строк, на которые он влияет. <br>Поскольку другие транзакции не могут обновлять или удалять строки в диапазоне, текущая транзакция позволяет избежать неповторяемых операций чтения. Поскольку другие транзакции не могут вставлять какие-либо строки в диапазоне, текущая транзакция позволяет избежать каких-либо **фантомов**. Транзакция освобождает свою блокировку при фиксации или откате. |



---
Статья [тут](https://docs.microsoft.com/ru-ru/sql/odbc/reference/develop-app/transaction-isolation-levels?view=sql-server-ver16) <br>
Статья на [Хабр](https://habr.com/ru/post/555920/)

