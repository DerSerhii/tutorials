# Django - Валидация форм и полей

Валидация формы происходит при очистке данных.
Если вы хотите настроить этот процесс, есть различные места для внесения изменений,
каждое из которых служит для разных целей. <br>
В процессе обработки формы выполняются ***три типа методов очистки***. <br>
Обычно они выполняются, когда вы вызываете метод `is_valid()` на форме. <br>
Есть и другие вещи, которые также могут вызвать очистку и проверку 
(обращение к атрибуту `errors` или прямой вызов `full_clean()`),
но обычно они не нужны.

В общем, любой метод очистки может поднять `ValidationError`, если есть проблема
с данными, которые он обрабатывает, передавая соответствующую информацию 
конструктору ValidationError. Если не поднимается `ValidationError`, метод должен 
вернуть очищенные (нормализованные) данные в виде объекта Python.

Большинство валидаций можно выполнить с помощью `validators` - помощников, 
которые можно использовать повторно. Валидаторы - это функции (или callables), 
которые принимают один аргумент и вызывают `ValidationError`
при недопустимом вводе. Валидаторы запускаются после вызова методов `to_python()` 
и `validate()` поля.

Валидация формы разбита на несколько этапов, которые можно настроить или отменить:

- Метод `to_python()` на `Field` является первым шагом в каждой валидации. 

 Он преобразует значение к правильному типу данных и выдает сообщение 
 `ValidationError`, если это невозможно. Этот метод принимает необработанное 
 значение от виджета и возвращает преобразованное значение. Например, `FloatField` 
 превратит данные в Python `float` или выдаст `ValidationError`.
 
- Метод `validate()` на `Field` обрабатывает специфическую для поля валидацию, 
которая не подходит для валидатора.

Он принимает значение, которое было приведено к правильному типу данных, и при 
любой ошибке выдает сообщение `ValidationError`. Этот метод ничего не возвращает и 
не должен изменять значение. Вы должны переопределить его для обработки логики 
валидации, которую вы не можете или не хотите поместить в валидатор.

- Метод `run_validators()` на поле `Field` запускает все валидаторы поля и 
 объединяет все ошибки в один `ValidationError`.
Вам не нужно переопределять этот метод.


- Метод `clean()` в подклассе `Field` отвечает за выполнение `to_python()`, 
`validate()` и `run_validators()` в правильном порядке и распространение их ошибок.
Если в любой момент времени какой-либо из методов вызывает ошибку `ValidationError`,
валидация останавливается, и эта ошибка выдается.

Этот метод возвращает чистые данные, которые затем вставляются в словарь `cleaned_data` формы.

- Метод `clean_<fieldname>()` вызывается на подклассе формы – где `<fieldname>`
заменяется на имя атрибута поля формы. 

Этот метод выполняет любую очистку, специфичную для данного атрибута, 
не связанную с типом поля, которым он является. Этому методу не передаются никакие 
параметры. Вам нужно будет найти значение поля в `self.cleaned_data` и помнить, 
что в этот момент это будет объект Python, а не исходная строка, представленная в 
форме (она будет в `cleaned_data`, потому что метод general field `clean()`, 
описанный выше, уже однажды очистил данные).

- Метод `clean()` подкласса формы может выполнять валидацию, требующую доступа к 
нескольким полям формы. 
 
Сюда можно отнести такие проверки, как «если поле A предоставлено, то поле B должно
содержать действительный адрес электронной почты». При желании этот метод может вернуть совершенно другой словарь, 
который будет использован в качестве `cleaned_data`.

Эти методы выполняются в указанном выше порядке, по одному полю за раз.

То есть, для каждого поля формы (в порядке их объявления в определении формы)
выполняется метод `Field.clean()` (или его переопределение), затем 
`clean_<fieldname>()`. Наконец, когда эти два метода выполнены для каждого поля,
выполняется метод `Form.clean()`, или его переопределение, 
независимо от того, вызвали ли предыдущие методы ошибки.

Статья [Валидация форм и полей](https://django.fun/docs/django/ru/4.0/ref/forms/validation/) 