# Итератор

[**Итератор**](https://refactoring.guru/ru/design-patterns/iterator) — это *поведенческий* 
[паттерн проектирования](Паттерн.md), который даёт возможность последовательно обходить элементы 
составных объектов, не раскрывая их внутреннего представления.

Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции 
в отдельный класс.

***Итерируемый объект*** — это что-то, что можно итерировать.

***Итератор*** — это сущность порождаемая функцией **iter**, с помощью которой происходит итерирование итерируемого объекта.

Итератор не имеет индексов и может быть использован только один раз.

##### Протокол итератора

Теперь формализуем протокол итератора целиком:

1. Чтобы получить итератор мы должны передать функции iter итерируемый объект.
2. Далее мы передаём итератор функции next.
3. Когда элементы в итераторе закончились, порождается исключение StopIteration.

Особенности:

- Любой объект, передаваемый функции **iter** без исключения TypeError — итерируемый объект.
- Любой объект, передаваемый функции **next** без исключения TypeError — итератор.
- Любой объект, передаваемый функции **iter** и возвращающий сам себя — итератор.

Плюсы итераторов:
1. Итераторы работают "лениво" (en. lazy). А это значит, что они не выполняют какой-либо работы, до тех пор, пока мы их об этом не попросим.
2. Таким образом, мы можем оптимизировать потребление ресурсов ОЗУ и CPU, а так же создавать бесконечные последовательности.


**Итератор (iterator)** — это объект, который возвращает свои элементы по одному за раз.

С точки зрения Python — это любой объект, у которого есть метод `__next__`. Этот метод возвращает следующий элемент, если он есть, или возвращает исключение StopIteration, когда элементы закончились.

Кроме того, итератор запоминает, на каком объекте он остановился в последнюю итерацию.

В Python у каждого итератора присутствует метод `__iter__` — то есть, 
любой итератор является итерируемым объектом. Этот метод просто возвращает сам итератор.

#### Пример создания итератора из списка:
```
In [3]: numbers = [1, 2, 3]

In [4]: i = iter(numbers)
```
Теперь можно использовать функцию **next()**, которая вызывает метод `__next__`, чтобы взять следующий элемент:
```
In [5]: next(i)
Out[5]: 1

In [6]: next(i)
Out[6]: 2

In [7]: next(i)
Out[7]: 3

In [8]: next(i)
------------------------------------------------------------
StopIteration              Traceback (most recent call last)
<ipython-input-8-bed2471d02c1> in <module>()
----> 1 next(i)

StopIteration:
```
После того, как элементы закончились, возвращается исключение StopIteration.

Для того, чтобы итератор снова начал возвращать элементы, его надо заново создать.

Итераторы полезны тем, что они отдают элементы по одному. Например, при работе с файлом это полезно тем, 
что в памяти будет находиться не весь файл, а только одна строка файла.

[Статья на Хабр](https://habr.com/ru/post/488112/)