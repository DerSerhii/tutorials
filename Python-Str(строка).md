# Str (строки)

***Строки*** в python — упорядоченные последовательности символов, используемые для хранения и представления 
текстовой информации, поэтому с помощью строк можно работать со всем, что может быть представлено в текстовой форме.

### Литералы строк

#### Строки в апострофах и в кавычках
```
s = 'spam"s'
s = "spam's"
```
Строки в апострофах и в кавычках - одно и то же. <br> 
Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, 
не используя экранирование

#### Экранированные последовательности - служебные символы
`\n` — перевод строки <br>
`\a` — звонок <br>
`\b` — забой <br>
`\f` — перевод страницы <br>
`\r` — возврат каретки <br>
`\t` — горизонтальная табуляция <br>
`\v` — вертикальная табуляция <br>
`\N{id}` — идентификатор ID базы данных Юникода <br>
`\uhhhh` — 16-битовый символ Юникода в 16-ричном представлении <br>
`\Uhhhh…` — 32-битовый символ Юникода в 32-ричном представлении <br>
`\xhh` — 16-ричное значение символа <br>
`\ooo` — 8-ричное значение символа <br>
`\0` — символ Null (не является признаком конца строки) <br>

#### "Сырые" строки - подавляют экранирование

Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм экранирования отключается.
```python
s = r'C:\newt.txt'
```
Но, несмотря на назначение, "сырая" строка не может заканчиваться символом обратного слэша. Пути решения:
```python
s = r'\n\n\\'[:-1]
s = r'\n\n' + '\\'
s = '\\n\\n'
```
#### Строки в тройных апострофах или кавычках

Главное достоинство строк в тройных кавычках в том, что их можно использовать для записи многострочных блоков текста. 
Внутри такой строки возможно присутствие кавычек и апострофов, главное, чтобы не было трех кавычек подряд.
```python
>>> c = '''это очень большая
... строка, многострочный
... блок текста'''
>>> c
'это очень большая\nстрока, многострочный\nблок текста'
>>> print(c)
это очень большая
строка, многострочный
блок текста
```

### Базовые операции

Конкатенация (сложение):
```
>>> S1 = 'spam'
>>> S2 = 'eggs'
>>> print(S1 + S2)
'spameggs'
```
Дублирование строки:
```
>>> print('spam' * 3)
spamspamspam
```
Длина строки (функция len):
```
>>> len('spam')
4
```
Доступ по индексу:
```
>>> S = 'spam'
>>> S[0]
's'
>>> S[2]
'a'
>>> S[-2]
'a'
```
Извлечение среза: <br>
Оператор извлечения среза: [X:Y]. X – начало среза, а Y – окончание;
символ с номером Y в срез не входит. По умолчанию первый индекс равен 0,
а второй - длине строки.
```
>>> s = 'spameggs'
>>> s[3:5]
'me'
>>> s[2:-2]
'ameg'
>>> s[:6]
'spameg'
>>> s[1:]
'pameggs'
>>> s[:]
'spameggs'
```
Кроме того, можно задать шаг, с которым нужно извлекать срез.
```
>>> s[::-1]
'sggemaps'
>>> s[3:5:-1]
''
>>> s[2::2]
'aeg'
```
При вызове методов необходимо помнить, что строки в Python относятся к категории неизменяемых последовательностей,
то есть все функции и методы могут лишь создавать новую строку.
```
>>> s = 'spam'
>>> s[1] = 'b'
Traceback (most recent call last):
  File "", line 1, in
    s[1] = 'b'
TypeError: 'str' object does not support item assignment
>>> s = s[0] + 'b' + s[2:]
>>> s
'sbam'
```
### Функции и методы строк
`S = 'str'`; `S = "str";` `S = '''str'''`; `S = """str"""` — литералы строк

`S = "s\np\ta\nbbb"` — экранированные последовательности

`S = r"C:\temp\new"` — неформатированные строки (подавляют экранирование)

`S = b"byte"` — строка байтов

`S1 + S2` — конкатенация (сложение строк)

`S1 * 3` — повторение строки

`S[i]` — обращение по индексу

`S[i:j:step]` — извлечение среза

`len(S)` — длина строки

`S.find(str, [start], [end])` — поиск подстроки в строке. Возвращает номер первого вхождения или -1

`S.rfind(str, [start], [end])` — поиск подстроки в строке. Возвращает номер последнего вхождения или -1

`S.index(str, [start], [end])` — поиск подстроки в строке. Возвращает номер первого вхождения или вызывает `ValueError`

`S.rindex(str, [start], [end])` — поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает `ValueError`

`S.replace(шаблон, замена[, maxcount])`	— замена шаблона на замену. maxcount ограничивает количество замен

`S.split(символ)` — разбиение строки по разделителю

`S.isdigit()` — состоит ли строка из цифр

`S.isalpha()` — состоит ли строка из букв

`S.isalnum()` — состоит ли строка из цифр или букв

`S.islower()` — состоит ли строка из символов в нижнем регистре

`S.isupper()` — состоит ли строка из символов в верхнем регистре

`S.isspace()` — состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))

`S.istitle()` — начинаются ли слова в строке с заглавной буквы

`S.upper()`	— преобразование строки к верхнему регистру

`S.lower()`	— преобразование строки к нижнему регистру

`S.startswith(str)`	 — начинается ли строка `S` с шаблона `str`

`S.endswith(str)` — заканчивается ли строка `S` шаблоном `str`

`S.join(список)` — сборка строки из списка с разделителем `S`

`ord(символ)` — символ в его код ASCII

`chr(число)` — код ASCII в символ

`S.capitalize()` — переводит первый символ строки в верхний регистр, а все остальные в нижний

`S.center(width, [fill])` — возвращает отцентрованную строку, по краям которой стоит символ `fill` (пробел по умолчанию)

`S.count(str, [start], [end])` — возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)

`S.expandtabs([tabsize])` — возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам

`S.lstrip([chars])` — удаление пробельных символов в начале строки

`S.rstrip([chars])` — удаление пробельных символов в конце строки

`S.strip([chars])` — удаление пробельных символов в начале и в конце строки

`S.partition(шаблон)` — возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки

`S.rpartition(sep)` — возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку

`S.swapcase()` — переводит символы нижнего регистра в верхний, а верхнего – в нижний

`S.title()` — первую букву каждого слова переводит в верхний регистр, а все остальные в нижний

`S.zfill(width)` — делает длину строки не меньшей `width`, по необходимости заполняя первые символы нулями

`S.ljust(width, fillchar=" ")` — делает длину строки не меньшей `width`, по необходимости заполняя последние символы символом `fillchar`

`S.rjust(width, fillchar=" ")` — делает длину строки не меньшей `width`, по необходимости заполняя первые символы символом `fillchar`

`S.format(*args, **kwargs)` — форматирование строки