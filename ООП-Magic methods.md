# Magic methods

__`__magic_methods__`__ — это методы, которые отвечают за любые действия под "капотом".

Они всегда обрамлены двумя нижними подчеркиваниями.

### Конструктор, инициализатор, деструктор(финализатор) класса

`__new__(cls) и __init__(self)` — **конструктор** класса

`__init__(self)` — **инициализатор** класса 

`__del__(self)` — **деструктор** | **финализатор** класса

Конструктор объекта:
- Шаг 1. Создание объекта в памяти устройства (метод `__new__`) <br>
- Шаг 2. Инициализация - создание локальных свойств|атрибутов объекта (метод `__init__`) <br>


Подробнее — [Конструктор, инициализатор, деструктор класса ](ООП-Magic-new,init,del.md)

### Магические методы сравнения

`__eq__(self, other)` — определяет поведение оператора равенства `==`

`__ne__(self, other)` — определяет поведение оператора неравенства `!=`

`__lt__(self, other)` — определяет поведение оператора меньше `<`

`__gt__(self, other)` — определяет поведение оператора больше `>`

`__le__(self, other)` — определяет поведение оператора меньше или равно `<=`

`__ge__(self, other)` — определяет поведение оператора больше или равно `>=`

Подробнее [будет]

### Менеджеры контекста

***Менеджеры контекста*** позволяют выделять и освобождать ресурсы *строго по необходимости*.<br>
Поведение менеджера контекста [**with...as**](Python-Менеджер%20контекста%20With..as.md) 
определяется двумя магическими методами:

- `__enter__(self)`<br> 
Определяет, что должен сделать менеджер контекста *в начале блока*, 
созданного оператором `with`.<br> 
Возвращаемое `__enter__` значение и есть то значение, с которым производится работа 
внутри `with`.


- `__exit__(self, exception_type, exception_value, traceback)`<br>
Определяет действия менеджера контекста *после того*, как блок будет выполнен
(или прерван во время работы).<br> 
Может использоваться для контролирования исключений, чистки, любых действий которые 
должны быть выполнены незамедлительно после блока внутри `with`. 
Если блок выполнен успешно, `exception_type`, `exception_value`, и `traceback` будут 
установлены в `None`. 
В другом случае вы сами выбираете, перехватывать ли исключение или предоставить 
это пользователю; если вы решили перехватить исключение, убедитесь, что `__exit__` 
возвращает `True` после того как всё сказано и сделано. 
Если вы не хотите, чтобы исключение было перехвачено менеджером контекста, просто позвольте ему случиться.

Подробнее [будет]

### Обычные арифметические операторы

Подробнее 

### Магические методы преобразования типов

Подробнее 

### Магические методы представления своих классов

Часто бывает полезно представление класса в виде [строки](Python-Str(строка).md). <br> 
В python есть несколько методов, которые можно определить для 
настройки поведения [встроенных функций](Python-Встроенные%20функции.md) при представлении вашего класса.

`__str__(self)` — определяет поведение функции `str()`, вызванной для экземпляра вашего класса.

`__repr__(self)` — определяет поведение функции `repr()`, вызванной для экземпляра вашего класса. 

Главное отличие данных методов в целевой аудитории:
- `repr()` — предназначен для машинно-ориентированного вывода <br> 
(более того, это часто должен быть валидный код на python); 
- `str()` — предназначен для чтения людьми.

`__bytes__(self)` — вызывается функцией `bytes()` при преобразовании к байтам

Подробнее [будет]

### Протоколы
Подробнее 

### Вызываемые объекты
Как вы наверное уже знаете, в Питоне функции являются объектами первого класса. Это означает, что они могут быть переданы в функции или методы так же, как любые другие объекты. Это невероятно мощная особенность.

Специальный магический метод позволяет экземплярам вашего класса вести себя так, как будто они функции, тоесть вы сможете «вызывать» их, передавать их в функции, которые принимают функции в качестве аргументов и так далее. Это другая удобная особенность, которая делает программирование на Питоне таким приятным.

`__call__(self, [args...])`

Позволяет любому экземпляру вашего класса быть вызванным как-будто он функция. Главным образом это означает, что `x()` означает то же, что и `x.__call__()`. Заметьте, `__call__` принимает произвольное число аргументов; то есть, вы можете определить `__call__` так же как любую другую функцию, принимающую столько аргументов, сколько вам нужно.


`__call__`, в частности, может быть полезен в классах, чьи экземпляры часто изменяют своё состояние. «Вызвать» экземпляр может быть интуитивно понятным и элегантным способом изменить состояние объекта. Примером может быть класс, представляющий положение некоторого объекта на плоскости:
```python
class Entity:
    '''Класс, описывающий объект на плоскости. "Вызываемый", чтобы обновить позицию объекта.'''

    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        '''Изменить положение объекта.'''
        self.x, self.y = x, y
```



[Лекция тут](https://github.com/PonomaryovVladyslav/PythonCources/blob/master/lesson16.md)