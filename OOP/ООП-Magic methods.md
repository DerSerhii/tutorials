# Magic methods

`__magic_methods__` — это методы, которые отвечают за любые действия под "капотом".

Они всегда обрамлены двумя нижними подчеркиваниями.

## Спеціальні атрибути

- `object.__dict__`— *dict (cловник)* або інший об’єкт відображення, який використовується для зберігання атрибутів об’єкта (для запису).
```python
>>> class A: pass
... 
>>> x = A()
>>> x.b = 1

>>> A.__dict__
mappingproxy({'__module__': '__main__', '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None})

>>> x.__dict__
{'b': 1}
>>> x.__dict__['c'] = 'Add c'
>>> x.__dict__
{'b': 1, 'c': 'Add c'}
```
- `instance.__class__`— клас, до якого належить екземпляр класу (еквівалент:`type(instance)`).
```python
>>> class B: pass
... 
>>> a = B()
>>> a.__class__
<class '__main__.B'>
>>> type(a)
<class '__main__.B'>
```
- `class.__bases__`— кортеж базових класів об’єкта класу.   
```python
>>> class B: pass 
... 
>>> class C(B): pass
... 
>>> B.__bases__
(<class 'object'>,)
>>> C.__bases__
(<class '__main__.B'>,)
```

- `__doc__`  — предназначенный для хранения строки документации — docstring. <br>
`__slots__` — это атрибут, который можно добавить к классу при его определении. 
Вы определяете слоты с возможными атрибутами, которыми может обладать экземпляр 
объекта.Основными причинами использования `__slots__` на более высоком уровне 
являются:
1. Более быстрое получение и установка атрибутов из-за оптимизации структуры данных
2. Уменьшение использования памяти для экземпляров классов.
```python
class WithSlots:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x, self.y = x, y
```

## Конструктор, инициализатор, деструктор(финализатор) класса

`__new__(cls) и __init__(self)` — **конструктор** класса

`__init__(self)` — **инициализатор** класса 

`__del__(self)` — **деструктор** | **финализатор** класса

Конструктор объекта:
- Шаг 1. Создание объекта в памяти устройства (метод `__new__`) <br>
- Шаг 2. Инициализация - создание локальных свойств|атрибутов объекта (метод `__init__`) <br>


Подробнее — [Конструктор, инициализатор, деструктор класса ](ООП-Magic-new,init,del.md)

## Магические методы сравнения

`__eq__(self, other)` — определяет поведение оператора равенства `==`

`__ne__(self, other)` — определяет поведение оператора неравенства `!=`

`__lt__(self, other)` — определяет поведение оператора меньше `<`

`__gt__(self, other)` — определяет поведение оператора больше `>`

`__le__(self, other)` — определяет поведение оператора меньше или равно `<=`

`__ge__(self, other)` — определяет поведение оператора больше или равно `>=`

## Менеджеры контекста

***Менеджеры контекста*** позволяют выделять и освобождать ресурсы *строго по необходимости*.<br>
Поведение менеджера контекста [**with...as**](Python-Менеджер%20контекста%20With..as.md) 
определяется двумя магическими методами:

- `__enter__(self)`<br> 
Определяет, что должен сделать менеджер контекста *в начале блока*, 
созданного оператором `with`.<br> 
Возвращаемое `__enter__` значение и есть то значение, с которым производится работа 
внутри `with`.


- `__exit__(self, exception_type, exception_value, traceback)`<br>
Определяет действия менеджера контекста *после того*, как блок будет выполнен
(или прерван во время работы).<br> 
Может использоваться для контролирования исключений, чистки, любых действий которые 
должны быть выполнены незамедлительно после блока внутри `with`. 
Если блок выполнен успешно, `exception_type`, `exception_value`, и `traceback` будут 
установлены в `None`. 
В другом случае вы сами выбираете, перехватывать ли исключение или предоставить 
это пользователю; если вы решили перехватить исключение, убедитесь, что `__exit__` 
возвращает `True` после того как всё сказано и сделано. 
Если вы не хотите, чтобы исключение было перехвачено менеджером контекста, просто позвольте ему случиться.

## Арифметические операторы

## Преобразования типов

`__int__(self)` — преобразование типа в int.

`__long__(self)` — преобразование типа в long.

`__float__(self)` — преобразование типа в float.

`__complex__(self)` — преобразование типа в комплексное число.

`__oct__(self)` — преобразование типа в восьмеричное число.

`__hex__(self)` — преобразование типа в шестнадцатеричное число.

`__index__(self)` — преобразование типа к int, когда объект используется в срезах (выражения вида [start:stop:step]). Если вы определяете свой числовый тип, который может использоваться как индекс списка, вы должны определить __index__.

`__trunc__(self)` — вызывается при `math.trunc(self)`. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

`__coerce__(self, other)` — метод для реализации арифметики с операндами разных типов. __coerce__ должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.

## Представления своих классов

Часто бывает полезно представление класса в виде [строки](Python-Str(строка).md). <br> 
В python есть несколько методов, которые можно определить для 
настройки поведения [встроенных функций](Python-Встроенные%20функции.md) при представлении вашего класса.

`__str__(self)` — определяет поведение функции `str()`, вызванной для экземпляра 
вашего класса.

`__repr__(self)` — определяет поведение функции `repr()`, вызванной для экземпляра 
вашего класса. 

Главное отличие данных методов в целевой аудитории:
- `repr()` — предназначен для машинно-ориентированного вывода <br> 
(более того, это часто должен быть валидный код на python); 
- `str()` — предназначен для чтения людьми.

`__bytes__(self)` — вызывается функцией`bytes()`при преобразовании к байтам.

`__dir__(self)` — определяет поведение функции`dir()`, вызванной на экземпляре 
вашего класса. Этот метод должен возвращать пользователю список атрибутов. 
Обычно, определение **dir** не требуется, но может быть жизненно важно для 
интерактивного использования вашего класса, если вы переопределили **getattr** 
или **getattribute**, или каким-либо другим образом динамически создаёте атрибуты.

## Создание произвольных последовательностей (контейнерных типов)

Реализация произвольных контейнерных типов в python влечёт за собой использование 
*протоколов*.

Протокол для определения **неизменяемых** контейнеров (*необходимо определить*):
- `__len__`
- `__getitem__`

Протокол для определения **изменяемых** контейнеров (*необходимо определить*):
- `__len__`
- `__getitem__`
- `__setitem__`
- `__delitem__`

Протокол для определения [**итераторов**](../Python/Python-Iterator&Iterable.md) (*необходимо определить*):
- `__iter__`
- `__next__`

### Методы контейнеров

- `__iter__(self)`<br>
Возвращает итератор для контейнера. <br>
Итераторы возвращаются в множестве ситуаций, главным образом для 
[встроенной функции](Python-Встроенные%20функции.md) `iter()` 
и в случае перебора элементов контейнера выражением `for x in container`. <br> 
Итераторы сами по себе объекты и они тоже должны определять метод `__iter__`, 
который возвращает `self`
- `__next__(self)` <br>
Возвращает следующий объект в последовательности или `StopIteration`, 
если больше объектов нет

Подробнее [будет] 

## Вызываемые объекты
Как вы наверное уже знаете, в Питоне функции являются объектами первого класса. Это означает, что они могут быть переданы в функции или методы так же, как любые другие объекты. Это невероятно мощная особенность.

Специальный магический метод позволяет экземплярам вашего класса вести себя так, как будто они функции, тоесть вы сможете «вызывать» их, передавать их в функции, которые принимают функции в качестве аргументов и так далее. Это другая удобная особенность, которая делает программирование на Питоне таким приятным.

`__call__(self, [args...])`

Позволяет любому экземпляру вашего класса быть вызванным как-будто он функция. Главным образом это означает, что `x()` означает то же, что и `x.__call__()`. Заметьте, `__call__` принимает произвольное число аргументов; то есть, вы можете определить `__call__` так же как любую другую функцию, принимающую столько аргументов, сколько вам нужно.


`__call__`, в частности, может быть полезен в классах, чьи экземпляры часто изменяют своё состояние. «Вызвать» экземпляр может быть интуитивно понятным и элегантным способом изменить состояние объекта. Примером может быть класс, представляющий положение некоторого объекта на плоскости:
```python
class Entity:
    '''Класс, описывающий объект на плоскости. "Вызываемый", чтобы обновить позицию объекта.'''

    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        '''Изменить положение объекта.'''
        self.x, self.y = x, y
```

## Контроль доступа к атрибутам
[Инкапсуляцию](ООП-Инкапсуляция.md) Python реализует через «магию», а не явными модификаторами для 
методов и полей.

`__setattr__(self, name, value)` – автоматически вызывается при изменении свойства
`name` класса;

`__getattribute__(self, name)`– автоматически вызывается при получении свойства 
класса с именем `name`;

`__getattr__(self, name)` – автоматически вызывается при получении несуществующего 
свойства `name` класса;

`__delattr__(self, name))` – автоматически вызывается при удалении свойства `name` 
(неважно: существует оно или нет).

---

[Лекция тут](https://github.com/PonomaryovVladyslav/PythonCources/blob/master/lesson16.md)