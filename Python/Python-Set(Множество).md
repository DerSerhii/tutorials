# Set & Frozenset (Множество и Замороженное множество)

***Set (Множество)*** — это [mutable (изменяемый)](Python-Переменные&Типы%20данных.md)
тип данных. <br>
В то время как: <br>
***Frozenset (Замороженное множество)*** — это [immutable (неизменяемый)](Python-Переменные&Типы%20данных.md)
тип данных. 

**Set (Множество)** — это *unordered* (неупорядоченная) коллекция *distinct* 
(уникальных) объектов. <br>

Обязательные требования множества: <br>
• элементы должны быть *hashable* – хешируемыми; <br>
• элементы должны быть *distinct* – уникальные - не равны`!=`.

## Операции с ***set*** и его методы 
### Create ***set***
Создать **список** можно несколькими способами:<br> 
1) Обработать любой [итерируемый](Python-Iterator&Iterable.md) объект 
[встроенной функцией](Python-Встроенные%20функции.md)`set()`:
```python
>>> set('hello!')
{'!', 'e', 'o', 'h', 'l'}

>>> set([1,1,1,2,3])
{1, 2, 3}
```
2) С помощью литерала`{ }`:
```python
>>> s = {'a', 'b', 'c', 'd'}
>>> s
{'b', 'c', 'a', 'd'}    # случайный порядок 
>>> s
{'c', 'a', 'd', 'b'}    # случайный порядок 
>>> type(a)
<class 'set'>

НО !!!
>>> d = {}  # А так нельзя, создастся словарь!
>>> d
{}
>>> type(d)
<class 'dict'>

>>> d = set()
>>> d
set()
>>> type(d)
<class 'set'>
```

3) С помощью [Set Comprehension (генераторa множеств)](Python-Comprehension.md): <br>
```python
>>> {i ** 2 for i in range(10)}  # генератор множеств
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
```
Как видно из примера, множества имеет тот же литерал,
что и [словарь](Python-Dict%20(Словари).md), но пустое множество с помощью литерала
создать нельзя!

### Retrieve ***set***
С множествами можно выполнять разные операций: находить объединение, пересечение...

`x in s` — принадлежит ли`x`множеству`s` <br>
`x not in s` — отсутствует ли`x`во множестве`s` <br>
`len(s)` — число элементов в множестве (размер множества)
`set.copy()` — копия множества

#### Union (Объединение) 
`set.union(other, ...)` или `set | other | ...` <br>
Объединение множеств — это множество, которое объединяет элементы из этих множеств,
сохраняя только один экземпляр любых повторяющихся элементов
```python
>>> s1 = {1 ,2 ,3, 6}
>>> s2 = set((1, 2, 3, 4, 5))

>>> s1 | s2
{1, 2, 3, 4, 5, 6}

>>> s1.union(s2)
{1, 2, 3, 4, 5, 6}

>>> s1
{1, 2, 3, 6}
```

#### Intersections (Пересечение)
`set.intersection(other, ...)` или `set & other & ...` <br>
Пересечение двух множеств — это множество, содержащее только те элементы,
которые являются общими для обоих множеств.
```python
>>> s1 = {1 ,2 ,3, 6}
>>> s2 = set((1, 2, 3, 4, 5))

>>> s1 & s2
{1, 2, 3}

>>> s1.intersection(s2)
{1, 2, 3}

>>> s1
{1, 2, 3, 6}
```

#### Differences of two sets (Разность двух множеств)
`set.difference(other, ...)` или `set - other - ...` <br>
Разность двух множеств — это все элементы одного множества без элементов
другого множества.
```python
>>> s1 = {1 ,2 ,3, 6}
>>> s2 = set((1, 2, 3, 4, 5))

>>> s1 - s2
{6}
>>> s1.difference(s2)
{6}

>>> s2 - s1
{4, 5}
>>> s2.difference(s1)
{4, 5}

>>> s1
{1, 2, 3, 6}
>>> s2
{1, 2, 3, 4, 5}
```

#### Symmetric Difference of two Sets (Симметричная разность двух множеств)
`set.symmetric_difference(other)` или `set ^ other` <br>
Симметричная разность двух множеств — это объединение обоих множеств без
пересечения обоих множеств.
```python
>>> s1 = {1 ,2 ,3, 6}
>>> s2 = set((1, 2, 3, 4, 5))

>>> s1 ^ s2
{4, 5, 6}
>>> s1.symmetric_difference(s2)
{4, 5, 6}

>>> s1
{1, 2, 3, 6}
>>> s2
{1, 2, 3, 4, 5}
```

#### Disjoint Sets (Непересекающиеся множества)
`set.isdisjoint(other) -> True` или `len(set & other) -> 0` <br>
Два множества называются непересекающимися, если их пересечение является пустым
множеством.
```python
>>> s1 = {1 ,2 ,3, 6}
>>> s2 = set((1, 2, 3, 4, 5))
>>> s3 = {i for i in range(7, 10)}
>>> s3
{8, 9, 7}

>>> s1.isdisjoint(s2)
False
>>> s1.isdisjoint(s3)
True

>>> len(s1 & s2)
3
>>> len(s1 & s3)
0
```

#### Subsets (Подмножества)
`set.issubset(other)` или `set <= other` <br>
Множество`set`является *подмножеством*`other`—
если все элементы`set`принадлежат`other`
```python
>>> s1 = {1, 2, 3}
>>> s2 = {1, 2, 3, 4}

>>> s1 <= s2
True
>>> s2 <= s1
False

>>> s1.issubset(s2)
True
```
Множество`set`является *proper(правильным) подмножеством*`other`—
если`set`является подмножеством`other` и `set`не равно`other`.
```python
>>> {1, 2, 3} < {1, 2, 3, 4}
True

>>> {1, 2, 3} < {1, 2, 3}
False

>>> {1, 2, 3} <= {1, 2, 3}
True
```

#### Supersets (Супермножества)
`set.issuperset(other)` или `set >= other`
Множество`set`является супермножеством`other`—
если`other`является подмножеством`set`.
```python
>>> s1 = {1, 2, 3}
>>> s2 = {1, 2, 3, 4}

>>> s2 >= s1
True
>>> s1 >= s2
False

>>> s2.issuperset(s2)
True
>>> s1.issuperset(s2)
False
```
Множество`set`является *proper(правильным) супермножеством*`other`—
если`other`является подмножеством`set` и `set`не равно`other`.

### Update ***set***
И операции, непосредственно изменяющие множество:

`set.update(other, ...)` или `set |= other | ...` — объединение

`set.intersection_update(other, ...)` или `set &= other & ...` — пересечение

`set.difference_update(other, ...)` или `set -= other | ...` — вычитание

`set.symmetric_difference_update(other)` или `set ^= other` — множество из элементов, встречающихся в одном множестве, но не встречающиеся в обоих

`set.add(elem)` — добавляет элемент в множество

### Delete ***set***

`set.remove(elem)` — удаляет элемент из множества. `KeyError`, если такого элемента не существует

`set.pop()` — удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым

`set.discard(elem)` — удаляет элемент, если он находится в множестве

`set.clear()` — очистка множества


## Применение множеств
Множества удобно использовать для удаления повторяющихся элементов:
```python
>>> words = ['hello', 'daddy', 'hello', 'mum', 'hello']
>>> set(words)
{'hello', 'daddy', 'mum'}
```


### Frozenset

Единственное отличие `set` от `frozenset` заключается в том, что <br>
`set` — изменяемый тип данных <br>
`frozenset` - нет <br> 
Примерно похожая ситуация со [списками](Python-List%20(Списки).md) и [кортежами](Python-Tuple%20(Кортежи).md).

```
>>> a = set('qwerty')
>>> b = frozenset('qwerty')
>>> a == b
True

>>> type(a - b)
<class 'set'>
>>> type(a | b)
<class 'set'>

>>> a.add(1)
>>> b.add(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no attribute 'add'
```
