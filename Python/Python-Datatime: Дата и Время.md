# Модуль Datatime - Дата и Время

Модуль`datetime`предоставляет классы для управления *датами* и *временем*.

## Осведомленные и наивные объекты 

Объекты даты и времени могут быть отнесены к категории **«осведомленных»** 
или **«наивных»** в зависимости от того, содержат ли они информацию о часовом поясе.

Обладая достаточным знанием применимых алгоритмических и политических корректировок
времени, таких как информация о часовом поясе и переходе на летнее время, 
***осведомленный*** объект может определить свое местоположение относительно 
других осведомленных объектов.

***Наивный*** объект не содержит достаточно информации, чтобы однозначно определить 
свое местонахождение относительно других объектов даты/времени.

## Константы 
Модуль`datetime`экспортирует следующие константы: <br>
`datetime.MINYEAR` — наименьшее число года `MINYEAR` is `1`, допустимое в объекте`date`или`datetime` 
`datetime.MAXYEAR` — наименьшее число года `MAXYEAR` is `9999`, допустимое в объекте`date`или`datetime` 

## Доступные типы Datatime

Объекты этих типов — неизменяемы ([immutable](Python-Переменные&Типы данных.md)) <br>
Отношения подкласса:
```commandline
object
    timedelta
    tzinfo
        timezone
    time
    date
        datetime
```
- class **datetime.date** <br>
Идеализированная *наивная* дата, предполагающая, что текущий григорианский 
календарь всегда был и всегда будет действовать. <br>
Атрибуты:`year`,`month`,`day` <br>
- class **datetime.time** <br>
Идеализированное время, не зависящее от какого-либо конкретного дня, при условии, 
что в каждом дне ровно (24 x 60 x 60) секунд. <br>
Атрибуты:`hour`,`minute`,`second`,`microsecond`,`tzinfo`
- class **datetime.timedelta** <br>
Сочетание даты и времени. <br>
Атрибуты: `year`,`month`,`day`,`hour`,`minute`,`second`,`microsecond`,`tzinfo`
- class **datetime.datetime**
Длительность, выражающая разницу между двумя экземплярами`date`,`time`или`datetime`
с разрешением в микросекундах.
- class **datetime.tzinfo** <br>
Абстрактный базовый класс для информационных объектов часового пояса. <br>
Они используются классами`datetime`и`time`для обеспечения настраиваемого понятия 
корректировки времени (например, для учета часового пояса и/или перехода на летнее время).
- class **datetime.timezone** <br>
Класс, который реализует`tzinfo`как фиксированное смещение от UTC.

### Общие свойства
Типы `date`,`datetime`,`time`и`timezone`имеют следующие общие черты:
- Объекты этих типов [неизменяемы](Python-Переменные&Типы данных.md).
- Объекты этих типов можно [хэшировать](../Хеш.md), то есть их можно использовать 
в качестве ключей [словаря (dict)](Python-Dict%20(Словари).md).
- Объекты этих типов поддерживают эффективное травление через `pickle`модуль.

### Определение того, является ли объект осведомленным или наивным 
Объекты`date`— всегда наивны. <br>
Объекты`time`или`datetime`— могут быть осознанным или наивным.

`datetime`объект`d`— *осведомлен*, если выполняются оба следующих условия:
1. `d.tzinfo`не является`None`
2. `d.tzinfo.utcoffset(d)`не возвращает`None`

В противном случае `d`— *наивен*.

`time`объект`t`— *осведомлен*, если выполняются оба следующих условия:
1. `t.tzinfo`не является`None`
2. `t.tzinfo.utcoffset(None)`не возвращает`None`
В противном случае `t`— *наивен*.

Различие между *осведомленным* и *наивным* не применяется к`timedelta`объектам.

## Объекты `timedelta`
Объект`timedelta`— это продолжительность, разницу между двумя *датами* или *временем*.

*class*`datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)` <br>
Все аргументы являются необязательными и по умолчанию равны `0` <br>
Аргументы могут быть целыми числами или числами с плавающей запятой, а также могут
быть положительными или отрицательными. <br>
Только *дни*, *секунды* и *микросекунды* хранятся внутри. Аргументы преобразуются в эти единицы: <br>
- Миллисекунда конвертируется в 1000 микросекунд
- Минута конвертируется в 60 секунд
- Час конвертируется в 3600 секунд
- Неделя преобразуется в 7 дней

а дни, секунды и микросекунды затем нормализуются, чтобы представление было уникальным, с <br>
- `0 <= microseconds < 1000000`
- `0 <= seconds < 3600*24`(количество секунд в одном дне)
- `999999999 <= days <= 999999999`


## Объекты `date`
Объект`date`представляет собой дату (год, месяц и день) в идеализированном календаре.

*class*`datetime.date(year, month, day)`
Требуются все аргументы. <br>
Аргументы должны быть целыми числами в следующих диапазонах: <br>
- `MINYEAR <= year <= MAXYEAR`
- `1 <= month <= 12`
- `1 <= day <= number of days in the given month and year`

## Объекты `datetime`
Объект`datetime`— это единый объект, содержащий всю информацию от`date`объекта 
и`time`объекта. <br>


#### Методы класса:
- *classmethod*`datetime.combine(date, time, tzinfo=self.tzinfo)` <br>
Возвращает новый`datetime`объект, компоненты *даты* которого равны компонентам данного 
`date`объекта, а компоненты *времени* равны компонентам данного`time`объекта. <br>
Если указан аргумент`tzinfo`, его значение используется для установки`tzinfo`атрибута 
результата, в противном случае используется`tzinfo`атрибут аргумента времени.

etc

## Объекты `time`
Объект`time`представляет собой (местное) время суток, не зависящее от какого-либо 
конкретного дня и подлежащее корректировке с помощью`tzinfo`объекта.

class `datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)` <br>
Все аргументы являются необязательными. <br>
`tzinfo`может быть `None`или экземпляром`tzinfo`подкласса. <br>
Остальные аргументы должны быть целыми числами в следующих диапазонах: <br>
-`0 <= hour < 24` <br>
-`0 <= minute < 60` <br>
-`0 <= second < 60` <br>
-`0 <= microsecond < 1000000` <br>
-`fold in [0, 1]`

#### Атрибуты класса
`time.min` — самое раннее время `time(0, 0, 0, 0)` <br>
`time.max` — самое позднее время `time(23, 59, 59, 999999)`<br>
`time.tzinfo` — объект, переданный в качестве аргумента`tzinfo=`конструктору
(или`None`если ничего не передается) <br>  
etc

## Форматирование дат и времени

Для форматирования объектов `date` и `time` в обоих этих классах предусмотрен 
метод `strftime(format)`. Этот метод принимает только один параметр, указывающий на 
формат, в который нужно преобразовать дату или время.

Для определения формата мы можем использовать один из следующих кодов форматирования:<br>
`%a` — аббревиатура дня недели. Например, Wed - от слова Wednesday (по умолчанию используются английские наименования)<br>
`%A` — день недели полностью, например, Wednesday<br>
`%b` — аббревиатура названия месяца. Например, Oct (сокращение от October)<br>
`%B` — название месяца полностью, например, October<br>
`%d` — день месяца, дополненный нулем, например, 01<br>
`%m` — номер месяца, дополненный нулем, например, 05<br>
`%y` — год в виде 2-х чисел<br>
`%Y` — год в виде 4-х чисел<br>
`%H` — час в 24-х часовом формате, например, 13<br>
`%I` — час в 12-ти часовом формате, например, 01<br>
`%M` — минута <br>
`%S` — секунда <br>
`%f` — микросекунда <br>
`%p` — указатель AM/PM <br>
`%c` — дата и время, отформатированные под текущую локаль <br>
`%x` — дата, отформатированная под текущую локаль <br>
`%X` — время, форматированное под текущую локаль <br>

Используем различные форматы:
```python
from datetime import datetime
now = datetime.now()
print(now.strftime("%Y-%m-%d"))             # 2017-05-03
print(now.strftime("%d/%m/%Y"))             # 03/05/2017
print(now.strftime("%d/%m/%y"))             # 03/05/17
print(now.strftime("%d %B %Y (%A)"))        # 03 May 2017 (Wednesday)
print(now.strftime("%d/%m/%y %I:%M"))       # 03/05/17 01:36
```

При выводе названий месяцев и дней недели по умолчанию используются английские 
наименования. Если мы хотим использовать текущую локаль, но то мы можем ее 
предварительно установить с помощью модуля `locale`:
```python
from datetime import datetime
import locale
locale.setlocale(locale.LC_ALL, "")
 
now = datetime.now()
print(now.strftime("%d %B %Y (%A)"))        # 03 Май 2017 (среда)
```

## Сложение и вычитание дат и времени

Нередко при работе с датами возникает необходимость добавить к какой-либо дате 
определенный промежуток времени или, наоборот, вычесть некоторый период. 
И специально для таких операций в модуле `datetime` определен класс `timedelta`. 
Фактически этот класс определяет некоторый период времени.

Для определения промежутка времени можно использовать конструктор `timedelta`:
```python
timedelta([days] [, seconds] [, microseconds] [, milliseconds] [, minutes] [, hours] [, weeks])
```
В конструктор мы последовательно передаем дни, секунды, микросекунды, миллисекунды, минуты, часы и недели.

Определим несколько периодов:
```python
from datetime import timedelta
 
three_hours = timedelta(hours=3)
print(three_hours)       # 3:00:00
three_hours_thirty_minutes = timedelta(hours=3, minutes=30)  # 3:30:00
 
two_days = timedelta(2)  # 2 days, 0:00:00
 
two_days_three_hours_thirty_minutes = timedelta(days=2, hours=3, minutes=30)  # 2 days, 3:30:00
```

Используя `timedelta`, мы можем складывать или вычитать даты. 
Например, получим дату, которая будет через два дня:
```python
from datetime import timedelta, datetime
 
now = datetime.now()
print(now)                      # 2017-05-03 17:46:44.558754
two_days = timedelta(2)
in_two_days = now + two_days
print(in_two_days)              # 2017-05-05 17:46:44.558754
```
Или узнаем, сколько было времени 10 часов 15 минут назад, 
то есть фактически нам надо вычесть из текущего времени 10 часов и 15 минут:
```python
from datetime import timedelta, datetime
 
now = datetime.now()
till_ten_hours_fifteen_minutes = now - timedelta(hours=10, minutes=15)
print(till_ten_hours_fifteen_minutes) 
```

## Свойства timedelta

Класс `timedelta` имеет несколько свойств, с помощью которых мы можем получить 
временной промежуток:
- `days`: возвращает количество дней <br>
- `seconds`: возвращает количество секунд <br>
- `microseconds`: возвращает количество микросекунд

Кроме того, метод `total_seconds()` возвращает общее количество секунд, куда входят 
и дни, и собственно секунды, и микросекунды.

Например, узнаем какой временной период между двумя датами:
```python
from datetime import timedelta, datetime
 
now = datetime.now()
twenty_two_may = datetime(2017, 5, 22)
period = twenty_two_may - now
print("{} дней  {} секунд   {} микросекунд".format(period.days, period.seconds, period.microseconds))
# 18 дней  17537 секунд   72765 микросекунд
 
print("Всего: {} секунд".format(period.total_seconds()))
# Всего: 1572737.072765 секунд
```

## Сравнение дат
Также как и строки и числа, даты можно сравнивать с помощью стандартных операторов 
сравнения:
```python
from datetime import datetime
 
now = datetime.now()
deadline = datetime(2017, 5, 22)
if now > deadline:
    print("Срок сдачи проекта прошел")
elif now.day == deadline.day and now.month == deadline.month and now.year == deadline.year:
    print("Срок сдачи проекта сегодня")
else:
    period = deadline - now
    print("Осталось {} дней".format(period.days))
```

## Свойства replace
```python
    def check_period_refund(self):
        current_time = timezone.now()
        time_purchase = self.purchase.time_purchase
        refund_end_time = time_purchase.replace(minute=time_purchase.minute + self.refund_period)
        check = current_time < refund_end_time
        return check
```

---
Документация Python - [Datatime](https://docs.python.org/3/library/datetime.html)  
Часовые пояса в [Django](../Django/Django-Часовые%20пояса.md)