# Magic methods & Special Attributes

`__magic_methods__` — это методы, которые отвечают за любые действия под "капотом".

Они всегда обрамлены двумя нижними подчеркиваниями.

## Спеціальні атрибути

- `object.__dict__`— [dict (cловник)](../DataTypes/Dict_(Словник).md) або інший об’єкт відображення, який використовується для зберігання атрибутів об’єкта (для запису).
```python
>>> class A: pass
... 
>>> x = A()
>>> x.b = 1

>>> A.__dict__
mappingproxy({'__module__': '__main__', '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None})

>>> x.__dict__
{'b': 1}
>>> x.__dict__['c'] = 'Add c'
>>> x.__dict__
{'b': 1, 'c': 'Add c'}
```
- `instance.__class__`— клас, до якого належить екземпляр класу (еквівалент:`type(instance)`).
```python
>>> class B: pass
... 
>>> a = B()
>>> a.__class__
<class '__main__.B'>
>>> type(a)
<class '__main__.B'>
```
- `class.__bases__`— [tuple (кортеж)](../DataTypes/Tuple_(Кортеж).md) базових класів об’єкта класу.   
```python
>>> class B: pass 
... 
>>> class C(B): pass
... 
>>> B.__bases__
(<class 'object'>,)
>>> C.__bases__
(<class '__main__.B'>,)
```

- `__doc__`  — предназначенный для хранения строки документации — docstring. <br>
`__slots__` — это атрибут, который можно добавить к классу при его определении. 
Вы определяете слоты с возможными атрибутами, которыми может обладать экземпляр 
объекта.Основными причинами использования `__slots__` на более высоком уровне 
являются:
1. Более быстрое получение и установка атрибутов из-за оптимизации структуры данных
2. Уменьшение использования памяти для экземпляров классов.
```python
class WithSlots:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x, self.y = x, y
```

## Конструктор, инициализатор, деструктор(финализатор) класса

`__new__(cls) и __init__(self)` — **конструктор** класса

`__init__(self)` — **инициализатор** класса 

`__del__(self)` — **деструктор** | **финализатор** класса

Конструктор объекта:
- Шаг 1. Создание объекта в памяти устройства (метод `__new__`) <br>
- Шаг 2. Инициализация - создание локальных свойств|атрибутов объекта (метод `__init__`) <br>


Подробнее — [Конструктор, инициализатор, деструктор класса ](ООП-Magic-new,init,del.md)

## Магические методы сравнения

`__eq__(self, other)` — определяет поведение оператора равенства `==`

`__ne__(self, other)` — определяет поведение оператора неравенства `!=`

`__lt__(self, other)` — определяет поведение оператора меньше `<`

`__gt__(self, other)` — определяет поведение оператора больше `>`

`__le__(self, other)` — определяет поведение оператора меньше или равно `<=`

`__ge__(self, other)` — определяет поведение оператора больше или равно `>=`

## Менеджеры контекста

***Менеджеры контекста*** позволяют выделять и освобождать ресурсы *строго по необходимости*.<br>
Поведение менеджера контекста [**with...as**](Python-Менеджер%20контекста%20With..as.md) 
определяется двумя магическими методами:

- `__enter__(self)`<br> 
Определяет, что должен сделать менеджер контекста *в начале блока*, 
созданного оператором `with`.<br> 
Возвращаемое `__enter__` значение и есть то значение, с которым производится работа 
внутри `with`.


- `__exit__(self, exception_type, exception_value, traceback)`<br>
Определяет действия менеджера контекста *после того*, как блок будет выполнен
(или прерван во время работы).<br> 
Может использоваться для контролирования исключений, чистки, любых действий которые 
должны быть выполнены незамедлительно после блока внутри `with`. 
Если блок выполнен успешно, `exception_type`, `exception_value`, и `traceback` будут 
установлены в `None`. 
В другом случае вы сами выбираете, перехватывать ли исключение или предоставить 
это пользователю; если вы решили перехватить исключение, убедитесь, что `__exit__` 
возвращает `True` после того как всё сказано и сделано. 
Если вы не хотите, чтобы исключение было перехвачено менеджером контекста, просто позвольте ему случиться.

## Арифметические операторы

## Преобразования типов

`__int__(self)` — преобразование типа в int.

`__long__(self)` — преобразование типа в long.

`__float__(self)` — преобразование типа в float.

`__complex__(self)` — преобразование типа в комплексное число.

`__oct__(self)` — преобразование типа в восьмеричное число.

`__hex__(self)` — преобразование типа в шестнадцатеричное число.

`__index__(self)` — преобразование типа к int, когда объект используется в срезах (выражения вида [start:stop:step]). Если вы определяете свой числовый тип, который может использоваться как индекс списка, вы должны определить __index__.

`__trunc__(self)` — вызывается при `math.trunc(self)`. Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

`__coerce__(self, other)` — метод для реализации арифметики с операндами разных типов. __coerce__ должен вернуть None если преобразование типов невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.

## Представления своих классов

Часто бывает полезно представление класса в виде [строки](Python-Str(строка).md). <br> 
В python есть несколько методов, которые можно определить для 
настройки поведения [встроенных функций](Python-Встроенные%20функции.md) при представлении вашего класса.

`__str__(self)` — определяет поведение функции `str()`, вызванной для экземпляра 
вашего класса.

`__repr__(self)` — определяет поведение функции `repr()`, вызванной для экземпляра 
вашего класса. 

Главное отличие данных методов в целевой аудитории:
- `repr()` — предназначен для машинно-ориентированного вывода <br> 
(более того, это часто должен быть валидный код на python); 
- `str()` — предназначен для чтения людьми.

`__bytes__(self)` — вызывается функцией`bytes()`при преобразовании к байтам.

`__dir__(self)` — определяет поведение функции`dir()`, вызванной на экземпляре 
вашего класса. Этот метод должен возвращать пользователю список атрибутов. 
Обычно, определение **dir** не требуется, но может быть жизненно важно для 
интерактивного использования вашего класса, если вы переопределили **getattr** 
или **getattribute**, или каким-либо другим образом динамически создаёте атрибуты.

## Создание произвольных последовательностей (контейнерных типов)

Реализация произвольных контейнерных типов в python влечёт за собой использование 
*протоколов*.

Протокол для определения **неизменяемых** контейнеров (*необходимо определить*):
- `__len__`
- `__getitem__`

Протокол для определения **изменяемых** контейнеров (*необходимо определить*):
- `__len__`
- `__getitem__`
- `__setitem__`
- `__delitem__`

Протокол для определения [**итераторов**](../Python/Python-Iterator&Iterable.md) (*необходимо определить*):
- `__iter__`
- `__next__`

### Методы контейнеров

- `__iter__(self)`<br>
Возвращает итератор для контейнера. <br>
Итераторы возвращаются в множестве ситуаций, главным образом для 
[встроенной функции](Python-Встроенные%20функции.md) `iter()` 
и в случае перебора элементов контейнера выражением `for x in container`. <br> 
Итераторы сами по себе объекты и они тоже должны определять метод `__iter__`, 
который возвращает `self`
- `__next__(self)` <br>
Возвращает следующий объект в последовательности или `StopIteration`, 
если больше объектов нет

Подробнее [будет] 

## Об'єкти, що викликаються
- `__call__(self, [args...])`

Цей магічний метод дозволяє екземплярам класу поводитись як [функція](../Functions/.Functions_(Функції).md). <br>
Тобто можна їх «викликати», передавати до функції як аргумент тощо. 

`x()`теж саме, що`x.__call__()`.

`__call__`може приймати будь-яку кількість аргументів.

Цей метод може бути корисним в класах, чиї екземпляри часто змінюють свій стан. «Викликати»
екземпляр може бути інтуїтивно зрозумілим та елегантним способом змінити стан об'єкта.

Прикладом може буть клас, що представляє знаходження деякого об'єкта на площині:
```python
class Entity:
    '''Клас, що описує об'єкт на площині.'''

    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        '''Змінити положення об'єкта.'''
        self.x, self.y = x, y
```



## Контроль доступа к атрибутам
[Инкапсуляцию](ООП-Инкапсуляция.md) Python реализует через «магию», а не явными модификаторами для 
методов и полей.

`__setattr__(self, name, value)` – автоматически вызывается при изменении свойства
`name` класса;

`__getattribute__(self, name)`– автоматически вызывается при получении свойства 
класса с именем `name`;

`__getattr__(self, name)` – автоматически вызывается при получении несуществующего 
свойства `name` класса;

`__delattr__(self, name))` – автоматически вызывается при удалении свойства `name` 
(неважно: существует оно или нет).

---

[Лекция тут](https://github.com/PonomaryovVladyslav/PythonCources/blob/master/lesson16.md)