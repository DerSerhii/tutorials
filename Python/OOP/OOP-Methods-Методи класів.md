# Методы классов

**Метод** — это [функция](../Python/Python-Функции.md), которая определена в 
[пространстве имен](../Пространство%20имен.md) 
класса, вызываемая с использованием точечной нотации.

Если обратится к методу через экземпляр, то получим специальный объект: 
объект привязанного метода (также называемого методом экземпляра).

Всего в [классе](ООП.md) существуют *три* типа методов:
- **метод объекта(экземпляра класса)** 
  - 'стандартный метод' - ничем не декларируются;
  - обязательный первый аргумент `self` (принимает объект класса);
  - метод характеризует как поведение конкретного объекта(экземпляра класса);
  - используя `self` можно *менять состояние объекта*;
  - используя `self.__class__` можно получить доступ к атрибутам класса и *менять состояние класса*; 
  - метод нельзя вызвать через класс без объекта!
- **метод класса**
  - декларируется с помощью декоратора `@classmethod`;
  - обязательный первый аргумент `cls` (принимает текущий класс);
  - метод принадлежит классу и характеризует *только поведение класса*, а не конкретного объекта!
  - изменение состояние класса отразиться на всех объектах этого класса!
  - метод можно вызвать через класс, без создания объекта класса!
- **статические методы**
  - декларируются с помощью декоратора `@staticmethod`;
  - нет обязательных аргументов;
  - не принадлежит ни классу, ни объекту - помещается потому, что подходит по смыслу;
  - не могут менять состояния ни класса, ни объекта!
  - метод можно вызвать через класс, без создания объекта класса!

Подробнее о [методах в python](https://medium.com/nuances-of-programming/python-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-%D0%B8-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-3e8529d24786#:~:text=Save-,Python%3A%20%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%2C%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20%D0%B8%20%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0,%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%2C%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20%D0%B8%20%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0.)
```python
class MyClass:
    def instancemethod(self):
        return 'instance method called', self
    
    @classmethod
    def classmethod(cls):
        return 'class method called', cls

    @staticmethod
    def staticmethod():
        return 'static method called'
```
Квинтэссенция:
- ***методы экземпляров*** класса позволяют менять как состояние определённого объекта,
так и класса;
- ***методы классов*** могут менять состояние класса, что отразится на всех объектах этого класса, 
но не могут менять
конкретный объект;
- ***статические методы*** прикреплены к классу лишь для удобства и не могут менять 
состояние ни класса, ни его экземпляра.

Интерпретатор python, когда вызывается тот или иной **метод** *через объект класса*, 
автоматически подставляет `self` в качестве первого аргумента.
```python
instance = MyClass()

MyClass.my_func(instance)
instance.my_func()
                  ^ self - добавлен автоматически интерпретатором 

MyClass.my_func(instance) - эквивалентная запись instance.my_func()
```
__`self`__ — это специальный *аргумент метода*, для получения ссылки на экземпляр объекта. 

Что бы проще было понять, на место self прилетает конкретный объект. self должен быть первым аргументом метода.

Объяснение **self** в python:
- у котов внутри есть "мурчалка"
- она реализована для всех котов в классе Кот
- в объекте кот надо как-то вызвать метод мурчало у класса Кот
- если вызвать кот.мурчало() - муркнут сразу все коты на свете
- если вызвать self.мурчало() - муркнет только тот кот, на которого указывает self

Методы класса `def my_func(self)` *не копируются* в экземпляры класса <br> 
и благодаря аргументу `self` мы знаем с каким экземпляром класса работает метод в данный 
момент.
.l,;
Когда использовать каждый из методов?
```python
from datetime import date

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_birth_year(cls, name, year):
        return cls(name, date.today().year - year)

    @staticmethod
    def is_adult(age):
        return age > 18

person1 = Person('Sarah', 25)
person2 = Person.from_birth_year('Roark', 1994)

>>> person1.name, person1.age
Sarah 25

>>> person2.name, person2.age
Roark 24

>>> Person.is_adult(25)
True
```
***Метод класса*** используется тогда, когда нужен генерирующий метод, 
возвращающий объект класса. <br>
Как видим, метод класса `from_birth_year` используется для создания объекта
класса `Person` по году рождения, а не возрасту.

***Статические методы*** в основном используются как вспомогательные функции 
и работают с данными, которые им передаются.


Методы — это тоже [атрибуты](ООП-Атрибуты%20классов%20и%20объектов.md) класса :)<br>
только они ведут не на данные, а на функции,<br>
а это значит можем получить доступ через функцию `getattr`
