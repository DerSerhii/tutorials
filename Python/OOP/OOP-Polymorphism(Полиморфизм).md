# Полиморфизм

`Полиморфизм`— одна из основных парадигм [ООП](ООП.md).

**Полиморфизм** — это возможность через единый интерфейс работать с объектами 
разных классов <br> 
<или> <br>
**Полиморфизм** — это множественная реализация одного интерфейса <br>
<т.е.> <br> способность одного и того же метода, действовать по-разному в 
зависимости от обстоятельств. 

***Пример из жизни*** <br>
У нас есть собаки и кошки, у каждого есть способность подать голос, 
но собака - *гавкнет*, а кошка - *мяукнет*. Результаты разные.

***Пример из Python*** <br>
- оператор `+` <br>
можем сложить числа, а можем и строки, и получим разный результат, но применим
один и тот же метод.
- [встроенная функция](../Python/Python-Встроенные%20функции.md) `len()`

***Пример кода*** <br>
```python
class English:
    def greeting(self):       
        print ("Hello")
        
class French:
    def greeting(self):
        print ("Bonjour")
  
def intro(language):               
    language.greeting()
    
flora  = English()
aalase = French()   
 
intro(flora)
intro(aalase)
```

## Формы полиморфизма
Различают полиморфизм — ***динамический*** и ***статический***.

### Динамический полиморфизм
Динамический полиморфизм позволяет получать доступ к методам, используя 
один и тот же интерфейс для различных типов объектов, которые могут 
реализовывать эти методы по-разному.

В динамическом полиморфизме выбор определяется *во время выполнения*.

#### Пример с кофеваркой 
Думайте о базовой кофеварке как о *классе* с *методом заваривания* кофе.
Входными параметрами для этого метода заваривания являются мерная ложка 
зерен и вода. На выходе получается чашка кофе. <br>
Другой тип кофеварки — френч-пресс. В нем также есть *метод заваривания* с 
точно такими же входами и выходами, как и в базовой кофеварке. Вволим ложку 
молотого кофе и воды. Затем через некоторое время нажимаем на поршень, и на 
выходе получается чашка горячего кофе. <br> 
Теперь, несмотря на то, что эти две кофеварки имеют одинаковые входы и выходы,
способ заваривания у них очень **разный (!)**. В базовой кофеварке используется
фильтр, а во френч-прессе кофе процеживается через металлическое сито. <br> 
И хотя полученные выходы представляют собой однотипные объекты, чашку кофе,
их атрибуты могут иметь несколько разные значения. <br>
Теперь, когда дело доходит до фактической реализации этого типа полиморфизма
в коде, есть несколько способов сделать это. <br>
Причудливый FrenchPress мог наследовать все атрибуты и методы от 
BasicCoffeeMaker. Но затем он заменяет метод заваривания, унаследованный от 
BasicCoffeeMaker, посредством процесса, называемого **переопределением**. 
Это позволяет FrenchPress пересмотреть свою 
собственную уникальную версию метода заваривания. <br> 
Или, возможно, обе эти кофеварки наследуются от одного и того же **абстрактного
класса** с **абстрактным методом** заваривания. <br>
Или они оба соглашаются реализовать один и тот же **интерфейс**. <br>
***Наследование, абстрактные классы и интерфейсы*** — все это возможные
реализации полиморфизма. <br> 
Преимущество динамического полиморфизма здесь в том, что он позволяет мне 
использовать любую форму кофеварки, если у нее есть метод заваривания, 
который принимает кофейную гущу и воду в качестве входных данных и 
возвращает чашку кофе. 

### Статический полиморфизм
Другая форма полиморфизма называется *статическим полиморфизмом*. <br>
Он использует функцию, называемую **перегрузкой методов**, которую 
не следует путать с **переопределением методов**.

В статическом полиморфизме выбор определяется *во время компиляции*.

***Перегрузка*** позволяет реализовать в классе несколько методов с 
одинаковым именем, но с *другим набором входных параметров*.

Но если изменить тип входных данных с кофе и воды на чайные листья и воду,
это будет другой набор параметров, поэтому френч-пресс выполнит другую версию
метода заваривания, которая вернет мне чашку горячего чая. <br> 
Заваривание с кофе и водой и заваривание с чаем и водой — это два разных 
метода с двумя разными сигнатурами.

В Python **нет возможности перегрузить метод класса**, как например в Java
(или С). Разные функции должны иметь разные имена.
```python
public class test {
    public static void main(String[] args) {
    }

    private void testrunner()
    {
    }

    private void testrunner(int i)
    {
    }

    private void testrunner(String c)
    {
    }
}
```
