# Global Interpreter Lock (GIL)

**Python Global Interpreter Lock (GIL)** — это своеобразная блокировка, позволяющая 
только одному потоку управлять интерпретатором Python. <br> 
Это означает, что в любой момент
времени будет выполняться только один конкретный [поток](../Поток&%20Процесс&%20GIL.md).

Работа GIL может казаться несущественной для разработчиков, создающих однопоточные 
программы. Но во многопоточных программах отсутствие GIL может негативно сказываться 
на производительности процессоро-зависымых программ.

Поскольку GIL позволяет работать только одному потоку даже в многопоточном приложении,
он заработал репутацию «печально известной» функции.

### Что за проблему в Python решает GIL?

Python подсчитывает количество ссылок для корректного управления памятью. 
Это означает, что созданные в Python объекты имеют переменную подсчёта ссылок, 
в которой хранится количество всех ссылок на этот объект. Как только эта переменная становится равной нулю, память, выделенная под этот объект, освобождается.

Вот небольшой пример кода, демонстрирующий работу переменных подсчёта ссылок:
```python
>>> import sys
>>> a = []
>>> b = a
>>> sys.getrefcount(a)
3
```
В этом примере количество ссылок на пустой массив равно 3. На этот массив ссылаются:
переменная `a`, переменная `b` и аргумент, переданный функции `sys.getrefcount()`.

Проблема, которую решает GIL, связана с тем, что в многопоточном приложении сразу 
несколько потоков могут увеличивать или уменьшать значения этого счётчика ссылок.
Это может привести к тому, что память очистится неправильно и удалится тот объект, 
на который ещё существует ссылка.

Счётчик ссылок можно защитить, добавив блокираторы на все структуры данных, которые 
распространяются по нескольким потокам. В таком случае счётчик будет изменяться 
исключительно последовательно.

Но добавление блокировки к нескольким объектам может привести к появлению другой 
проблемы — взаимоблокировки (англ. deadlocks), которая получается только если 
блокировка есть более чем на одном объекте. К тому же эта проблема тоже снижала бы 
производительность из-за многократной установки блокираторов.

GIL — эта одиночный блокиратор самого интерпретатора Python. 
Он добавляет правило: любое выполнение байткода в Python требует блокировки 
интерпретатора. В таком случае можно исключить взаимоблокировку, т. к. 
GIL будет единственной блокировкой в приложении. К тому же его влияние на 
производительность процессора совсем не критично. 
Однако стоит помнить, что GIL уверенно делает любую программу однопоточной.

Несмотря на то, что GIL используется и в других интерпретаторах, например в Ruby, 
он не является единственным решением этой проблемы. Некоторые языки решают проблему 
потокобезопасного освобождения памяти с помощью сборки мусора.

С другой стороны это означает, что такие языки часто должны компенсировать потерю 
однопоточных преимуществ GIL добавлением каких-то дополнительных функций повышения 
производительности, например JIT-компиляторов.