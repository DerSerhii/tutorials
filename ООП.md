# ООП
**Объектно-ориентированное программирование** — *парадигма программирования*, в которой
основными *концепциями* являются понятия *объектов* и *классов*. 

В центре ООП находится понятие **объекта**.

__`Класс`__ — это шаблон (чертеж) для создания **объекта**.

__`Объект`__ — это сущность, экземпляр класса, содержащий свои [аттрибуты](ООП-Атрибуты%20классов%20и%20объектов.md) 
и [методы](ООП-Методы%20классов.md), созданный при помощи шаблона (т.е. *класса*).

__`Атрибуты|Свойства класса`__ — это данные (переменные) принадлежащие *классу* и являются общими 
для всех экземпляров.

`Атрибуты|Свойства объекта` — это данные (переменные) внутри объекта и доступные только ему.

__`Метод`__ — это функция, которая определена в пространстве имен класса, вызываемая с использованием точечной нотации.

    Класс:                   - чертеж для создания объекта 
        аттрибуты|свойства   - данные(переменные) 
        методы(self)         - функции

    объект = Класс()         - экземпляр созданный по чертежу


__`self`__ — это специальный *аргумент метода*, для получения ссылки на экземпляр объекта. 

Что бы проще было понять, на место self прилетает конкретный объект. self должен быть первым аргументом метода.

Объяснение **self** в python:

- у котов внутри есть "мурчалка"
- она реализована для всех котов в классе Кот
- в объекте кот надо как-то вызвать метод мурчало у класса Кот
- если вызвать кот.мурчало() -  муркнут сразу все коты на свете
- если вызвать self.мурчало() -  муркнет только тот кот, на которого указывает self

## Парадигмы (концепции) ООП

ООП держится на трёх основных и одной второстепенной парадигме.

Основные парадигмы:
- `Инкапсуляция`
- `Наследование`
- `Полиморфизм`

Вспомогательная парадигма:
- `Абстракция`

### Инкапсуляция
[**Инкапсуляция**](ООП-Инкапсуляция.md) — это принцип помещения функционала(или данных) в "черный ящик" 
с предоставлением только входа и выхода.

Общая идея — показать, что есть данные(методы) разрешенные (бери - пользуйся), а есть — внутренние или системные 
(не трогай, а то сломаешь!). 

***Пример из жизни*** <br>
Если в автомобиле повернуть руль налево, то колёса тоже повернутся налево, 
но как именно это происходит от нас скрыто, мы не знаем какие именно рычаги и шестерёнки 
в этот момент двигаются внутри автомобиля.

Что бы скрыть данные для внешнего использования нужно называть аттрибуты или методы начиная 
с нижнего подчёркивания 
- _ *одинарное подчёркивание* вызовет предупреждение о том что элемент скрыт
- __ *двойное подчеркивание* не позволят получить доступ к этому атрибуту извне (хотя и есть способы).

В первую очередь код пишется для людей, поэтому инкапсуляция в python ***условная*** 
(именно в питоне, в большинстве других языков это строго ограничено).

### Наследование

[**Наследование**](ООП-Наследование.md) — это свойство системы, позволяющее описать новый класс на основе уже 
существующего и позаимствовать у него функционал (частично или полностью)..

Класс, от которого производится наследование, называется ***базовым***, ***родительским*** или 
***суперклассом***. 

Новый класс — ***потомком***, ***наследником*** или ***производным классом***.

***Пример из жизни*** <br>
У нас есть базовый класс автомобиль и три наследника, легковой, самосвал и фура, 
все три класса могут иметь общие атрибуты, например двигатель или материал лобового стекла, 
или методы, например газ и тормоз, но при этом иметь свои особенные атрибуты или методы, 
например, только у фуры будет больше чем 4 колеса, или у самосвала, будет метод поднять кузов, 
или у фуры отцепить груз.

Наследование может быть множественным. 

[**Множественное наследование**](ООП-Множественное%20наследование.md) — это возможность у класса 
потомка наследовать функционал не от одного, 
а от нескольких родителей.

Но у нескольких родителей будут одинаковые методы, возникает **ромбовидное наследование 
(diamond problem)** решается путем установления ***порядка разрешения методов 
[(MRO)](ООП-Diamond%20problem-MRO.md)***.

В наследовании могут участвовать классы-примеси — [миксины](ООП-Миксины.md).

### Полиморфизм

[**Полиморфизм**](ООП-Полиморфизм.md) — это возможность через единый интерфейс работать с объектами 
разных классов<br> 
т.е. способность одного и того же метода, действовать по-разному в зависимости от обстоятельств 
(например, обычный знак `+`, можем сложить числа, а можем и строки, 
и получим разный результат, но применим один и тот же метод).

***Пример из жизни*** <br>
У нас есть собаки и кошки, у каждого есть способность подать голос, но собака - 'гавкнет', 
кошка - 'мяукнет'. Результаты разные.*

### Абстракция

[**Абстракция**](ООП-Абстракция.md) — это предварительное описание без реализации 
(заготовка для будущего метода).

[Лекция тут](https://github.com/DerSerhii/PythonCources/blob/master/lesson15.md)