#  `__new__, __init__, __del__`

При создании (инициализации) объекта вызывается метод `__init__` и 
помогает нам задать стартовые параметры для нашего класса:

```python
class A:
    def __init__(self, arg_one, arg_two):
        self.some_arg_one = arg_one
        self.some_arg_two = arg_two

a = A('bla', 22)
a.some_arg_one
>>>bla
a.some_arg_two
>>>22
``` 
Когда я пишу x = SomeClass(), `__init__` не самое первое, что вызывается. 


На самом деле, экземпляр объекта создаёт метод `__new__`, 
а затем аргументы передаются в ***инициализатор***. 


На другом конце жизненного цикла объекта находится метод `__del__`. 

Давайте подробнее рассмотрим эти три магических метода:

- `__new__(cls, [...)`

Это первый метод, который будет вызван при инициализации объекта. 
Он принимает в качестве параметров класс и потом любые другие аргументы, 
которые будут переданы в `__init__`. 

`__new__` используется весьма редко, но иногда бывает полезен, в частности, 
когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка.

- `__init__(self, [...)`

Это второй метод - *Инициализатор* класса. 

Ему передаётся всё, с чем был вызван первоначальный конструктор 
(так, например, если мы вызываем x = SomeClass(10, 'foo'), 
`__init__` получит 10 и 'foo' в качестве аргументов. `__init__` почти повсеместно используется при определении классов.

- `__del__(self)`

Если `__new__` и `__init__` образуют **Конструктор объекта**, то `__del__` это его **Деструктор**.
Он не определяет поведение для выражения `del x` 
(поэтому этот код не эквивалентен `x.__del__()`). 
Скорее, он определяет поведение объекта в то время, когда объект попадает в сборщик мусора. 
Это может быть довольно удобно для объектов, которые могут требовать дополнительных чисток во 
время удаления, таких как сокеты или файловыве объекты. 
Однако, нужно быть осторожным, так как нет гарантии, что `__del__` будет вызван, 
если объект продолжает жить, когда интерпретатор завершает работу. 
Поэтому `__del__` не может служить заменой для хороших программистских практик 
(всегда завершать соединение, если закончил с ним работать и тому подобное). 
Фактически, из-за отсутствия гарантии вызова, `__del__` не должен использоваться почти никогда; 
используйте его с осторожностью.

[Лекция тут](https://github.com/PonomaryovVladyslav/PythonCources/blob/master/lesson16.md)
